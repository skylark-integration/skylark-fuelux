/**
 * skylark-fuelux - A version of fuelux that ported to running on skylarkjs
 * @author Hudaokeji, Inc.
 * @version v0.9.2
 * @link https://github.com/skylarkui/skylark-fuelux/
 * @license MIT
 */
define(["skylark-langx/langx","skylark-domx/browser","skylark-domx/eventer","skylark-domx/noder","skylark-domx/geom","skylark-domx/query","./fuelux"],function(e,t,i,a,o,r,s){var d=r.fn.radio,n=function(e){window&&window.console&&window.console.error&&window.console.error(e)},l=s.Radio=s.WidgetBase.inherit({klassName:"Radio",init:function(t,i){if(this.options=e.mixin({},r.fn.radio.defaults,i),"label"===t.tagName.toLowerCase()){this.$label=r(t),this.$radio=this.$label.find('input[type="radio"]'),this.groupName=this.$radio.attr("name"),!this.options.ignoreVisibilityCheck&&this.$radio.css("visibility").match(/hidden|collapse/)&&n("For accessibility reasons, in order for tab and space to function on radio, `visibility` must not be set to `hidden` or `collapse`. See https://github.com/ExactTarget/fuelux/pull/1996 for more details.");var a=this.$radio.attr("data-toggle");this.$toggleContainer=r(a),this.$radio.on("change",e.proxy(this.itemchecked,this)),this.setInitialState()}else n("Radio must be initialized on the `label` that wraps the `input` element. See https://github.com/ExactTarget/fuelux/blob/master/reference/markup/radio.html for example of proper markup. Call `.radio()` on the `<label>` not the `<input>`")},setInitialState:function(){var e=this.$radio,t=e.prop("checked"),i=e.prop("disabled");this.setCheckedState(e,t),this.setDisabledState(e,i)},resetGroup:function(){r('input[name="'+this.groupName+'"]').each(function(e,t){var i=r(t),a=i.parent(),o=i.attr("data-toggle"),s=r(o);a.removeClass("checked"),s.addClass("hidden")})},setCheckedState:function(e,t){var i=e,a=i.parent(),o=i.attr("data-toggle"),s=r(o);t?(this.resetGroup(),i.prop("checked",!0),a.addClass("checked"),s.removeClass("hide hidden"),a.trigger("checked.fu.radio")):(i.prop("checked",!1),a.removeClass("checked"),s.addClass("hidden"),a.trigger("unchecked.fu.radio")),a.trigger("changed.fu.radio",t)},setDisabledState:function(e,t){var i=r(e),a=this.$label;return t?(i.prop("disabled",!0),a.addClass("disabled"),a.trigger("disabled.fu.radio")):(i.prop("disabled",!1),a.removeClass("disabled"),a.trigger("enabled.fu.radio")),i},itemchecked:function(e){var t=r(e.target);this.setCheckedState(t,!0)},check:function(){this.setCheckedState(this.$radio,!0)},uncheck:function(){this.setCheckedState(this.$radio,!1)},isChecked:function(){return this.$radio.prop("checked")},enable:function(){this.setDisabledState(this.$radio,!1)},disable:function(){this.setDisabledState(this.$radio,!0)},destroy:function(){return this.$label.remove(),this.$label[0].outerHTML}});return l.prototype.getValue=l.prototype.isChecked,r.fn.radio=function(e){var t,i=Array.prototype.slice.call(arguments,1),a=this.each(function(){var a=r(this),o=a.data("fu.radio"),s="object"==typeof e&&e;o||a.data("fu.radio",o=new l(this,s)),"string"==typeof e&&(t=o[e].apply(o,i))});return void 0===t?a:t},r.fn.radio.defaults={ignoreVisibilityCheck:!1},r.fn.radio.Constructor=l,r.fn.radio.noConflict=function(){return r.fn.radio=d,this},r.fn.radio});
//# sourceMappingURL=sourcemaps/radio.js.map
